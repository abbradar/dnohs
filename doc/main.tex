% check for outdated packages, syntax etc.
\RequirePackage[l2tabu,orthodox]{nag}

\documentclass[a4paper,12pt]{article}
\usepackage{polyglossia}
\setdefaultlanguage{russian}

\usepackage[fleqn]{amsmath}
\usepackage{microtype}
\usepackage{unicode-math}
\usepackage[backend=biber]{biblatex}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{float}
\usepackage{tabu}
\usepackage{url}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage[style=english]{csquotes}
\usepackage{placeins}
\defaultfontfeatures{Mapping=tex-text}
\setmainfont{CMU Serif}
\setsansfont{CMU Sans Serif}
\setmonofont{CMU Typewriter Text}
\setmathfont{STIX Math}
\MakeOuterQuote{"}
\DeclareSymbolFont{letters}{\encodingdefault}{\rmdefault}{m}{it}

\bibliography{main}

\title{Компилятор языка Haskell -- фронтэнд}
\author{Амиантов Н.И., ИУ7-129}
\date{\today}

\newcommand{\sectionbreak}{\clearpage}
\newcommand{\subsectionbreak}{\FloatBarrier}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\begin{document}

\newgeometry{margin=1cm}
\begin{titlepage}
  \begin{center}
    \emph{Федеральное государственное бюджетное образовательное учреждение высшего
      профессионального образования}
    \begin{tabu} to \linewidth {lX[1,c,m]}
      \hline
      \includegraphics[width=0.15\linewidth]{crest} &
      \large\emph{``Московский государственный технический университет имени Н.Э.
        Баумана'' (МГТУ им. Н.Э. Баумана)} \\
    \end{tabu}
  \end{center}
  \begin{tabu}{ll}
    \large\textsc{Факультет:} & Информатика и системы управления \\
    \large\textsc{Кафедра:} & Программное обеспечение ЭВМ и информационные технологии \\
  \end{tabu}
  \vspace{1.0cm}
  \begin{center}
    \huge{Расчётно-пояснительная записка} \\
    \vspace{0.5cm}
    \Large{к курсовой работе по предмету ``Конструирование компиляторов'' на тему:} \\
    \vspace{0.3cm}
    \Large{``\thetitle''}
  \end{center}
  \vfill
  \begin{tabu} to \linewidth {Xr}
    Авторы: \theauthor & $\underset{\text{(Подпись, дата)}}{\text{\underline{
\makebox[5cm]{}}}}$ \\
    Научный руководитель: Просуков Е.А. & $\underset{\text{(Подпись, дата)}}{\text{\underline{
\makebox[5cm]{}}}}$ \\
  \end{tabu}
  \vspace{0.2cm}
  \begin{center}
    Москва \the\year
  \end{center}
\end{titlepage}
\restoregeometry

\tableofcontents

\section*{\thetitle}

\textit{\underline{Ключевые слова:}
  компиляторы, Haskell, синтаксический анализ, лямбда-счисление, вывод типов Хиндли-Милнера
}

\textit{\underline{Аннотация:}
  Реализован фронтэнд компилятора для упрощённого варианта языка
  программирования Haskell. Была разработала упрощённая грамматика языка, выбраны
  поддерживаемые возможности. Реализовано ПО, упрощающее исходный язык до
  типизированного лямбда-счисления (вариант System F с Case-инструкцией). Полученное
  выражение проверяется на верную типизированность-1 и -2 (types и
  kinds). Приводятся примеры ошибок, находимых компилятором.
}

Существует много разновидностей типизированных функциональных языков
программирования~\cite{agda}\cite{idris}\cite{ml}. Они различаются по
сложности теории, на которой они построены (вид лямбда-счисления), по форме
управления побочными эффектами (неявная, монадическая, эффектная) и по
разнообразному синтаксическому сахару. Весь язык обычно представляет себя
большое разнообразие поддерживаемого синтаксического сахара, которое может быть
преобразовано в одну из форм лямбда-счисления, состоящего из всего нескольких
инструкций. Над полученным выражением производятся проверки корректности,
оптимизации и собственно генерация исполняемого кода.

Для настоящей работы был выбрано подмножество стандарта Haskell
98~\cite{haskell98}, из которого были исключены тайпклассы, модули и несколько
синтаксических конструкций (do-нотация, паттерн-матчинг в let, определяемые
операторы, if-then-else). Поддерживаются оба вида задания вложенности
(layout-based и явная), полиморфизм, абстрактные типы данных.

\section{Описание языка}

За основу языка был взят стандарт Haskell 98, который был сильно упрощён. В
частности, в нашей реализации отсутствует стандартная библиотека и примитивы
компилятора (т.е. доступны только символьные вычисления). Предполагается что
примитивы и стандартная библиотека будут реализованы как часть работы по
созданию бэкэнда для нашей разработки (хотя некоторая поддержка примитивов будет
необходима во фронтэнде, их строгий набор зависит от реализации бэкэнда и потому
опущен). На рисунке~\ref{grammar} приводится итоговая грамматика языка.

\begin{figure}
  \begin{tabu}{lcl}
    Begin &\rightarrow &"\{" Tops "\}" \\
    Tops &\rightarrow &Top ";" Tops \\
    & | &$\epsilon$ \\
    Top &\rightarrow &Let \\
    & | &TyDecl \\
    TyDecl &\rightarrow &"data" con TyVars "=" TyCons \\
    TyVars &\rightarrow &val TyVars \\
    & | &$\epsilon$ \\
    TyCons &\rightarrow &TyCon "|" TyCons \\
    & | &TyCon \\
    TyCon &\rightarrow &con TopTypes \\
    TopTypes &\rightarrow &TypeTerm TopTypes \\
    & | &$\epsilon$ \\
    Type &\rightarrow &Type "->" Type \\
    & | &TypeApp \\
    TypeTerm &\rightarrow &val \\
    & | &con \\
    & | &"(" Type ")" \\
    TypeApp &\rightarrow &TypeApp TypeTerm \\
    & | &TypeTerm \\
    Let &\rightarrow &val "::" Type \\
    & | &val TopPats "=" Expr \\
    TopPats &\rightarrow &TopPat TopPats \\
    & | &$\epsilon$ \\
    TopPat &\rightarrow &OnePat \\
    & | &con \\
    Pat &\rightarrow &OnePat \\
    & | &con TopPats \\
    OnePat &\rightarrow &val \\
    & | &"\_" | "(" Pat ")" \\
    Expr &\rightarrow &Expr "::" Type \\
    & | &"let" "\{" Lets "\}" "in" Expr \\
    & | &"case" Expr "of" "\{" Alts "\}" \\
    & | &ExprApp \\
    Lets &\rightarrow &Let ";" Lets \\
    & | &$\epsilon$ \\
    Alts &\rightarrow &Pat "->" Expr ";" Alts \\
    & | &$\epsilon$ \\
    ExprApp &\rightarrow &ExprApp ExprTerm \\
    & | &ExprTerm \\
    ExprTerm &\rightarrow &val \\
    & | &con \\
    & | &"(" Expr ")"
  \end{tabu}
  \caption{Грамматика языка Mini Haskell}
  \label{grammar}
\end{figure}

Из полученной грамматики видно что в заданном языке отсутствуют несколько важных
возможностей Haskell -- тайп-классы (и как следствие, do-нотация) и
модули. Тайп-классы были опущены для упрощения работы над бэкэндом, хотя они
представляют из себя интересную область для реализации. Модули же не
предполагались, поскольку целью данной работы является в первую очередь изучение
процесса синтаксического анализа и работы над абстрактным синтаксическим
деревом, модули же представляют из себя инфраструктурное практическое
дополнение, важное для практики но мало касающееся данной области.

Также из грамматики были удалены задаваемые операторы. Это влечёт за собой
существенное усложнение парсера (необходимость считывать выражения парсером
операторной прецедентности, динамически в зависимости от заданных приоритетов в
коде), поэтому было принято решение сконцентрироваться на символьных
вычислениях. При необходимости для демонстрации работы бэкэнда они легко могут
быть добавлены прямо в исходную грамматику языка.

Нетерминалы грамматики приведены на рисунке~\ref{nonterms}. Они полностью
соответствуют стандарту Haskell 98. Дополнительно в реализованном ПО
присутствует распознавание чисел и строк; из-за отсутствия необходимых
примитивов они исключены из языка в настоящий момент, хотя могут быть
тривиальным образом добавлены.

\begin{figure}
    \$valueFst = [\_a-z] \\
    \$typeFst = [A-Z] \\
    \$letter = [[\$valueFst\$typeFst]0-9'] \\
    \$symbol = [+-!@\#\$\%\^\&*.] \\
    \\
    lineComment = "--" \\
    commentStart = "\{-" \\
    commentEnd = "-\}" \\
    let = "let" \\
    in = "in" \\
    case = "case" \\
    of = "of" \\
    data = "data" \\
    arrow = "->" \\
    oftype = "::" \\
    bar = "|" \\
    eq = "=" \\
    underscore = "\_" \\
    val = \$valueFst\$letter* \\
    con = \$typeFst\$letter* \\
    semicolon = ";" \\
    oparen = "(" \\
    cparen = ")" \\
    obrace = "\{" \\
    cbrace = "\}" \\
  \caption{Нетерминалы языка Mini Haskell}
  \label{nonterms}
\end{figure}

\section{Лексический анализ}

Лексический анализ выбранного языка сопряжён с некоторыми особенностями,
связанными с поддержкой языком распознавания вложенности на основе
отступов. Распознавание отвечает требованиям стандарта Haskell 98. Правила
отступов таковы:

\begin{enumerate}
\item Если новый блок начался с токена \texttt{``\{''}, то используется традиционный
  стиль распознавания вложенностей (Си-стиль, с символами ``точка с запятой'' на
  концах выражений).
\item Если блок начался с другого токена, позиция токена запоминается и
  вставляется токен \texttt{``\}''}.
\item Если последующий токен находится на следующей строке и большем столбце чем
  запомненный, продолжается текущее выражение.
\item Если следующий токен находится на следующей строке и на одинаковом столбце
  с запомненным, вставляется токен \texttt{``;''}.
\item Если следующий токен находится на следующей строке и на меньшем столбце
  чем запомненный, вставляется токен \texttt{``\}''} и блок считается завершённым.
\end{enumerate}

Подобные правила требуют взаимодействия между синтаксическим и лексическим
анализаторами. Оно реализуется следующим образом:

\begin{enumerate}
\item Таблица правил дополняется, как показано на рисунке~\ref{layoutgrammar}.
\item Синтаксический анализатор при свёртке правил \texttt{``BeginLet''} и
  \texttt{``BeginCase''} устанавливает флаг начала нового блока для лексического
  анализатора. Также устанавливается стоп-нетерминал (о нём позже).
\item Лексический анализатор при чтении токена проверяет верх стека блоков. Если
  наверху стека метка ``традиционный блок'' и встретился токен \texttt{``\}''},
  то вершина стека отбрасывается.
\item Если на вершине стека метка ``отступо-ориентированный блок'', то изучается
  позиция текущего токена:
  \begin{enumerate}
  \item Если токен находится на колонке меньшей чем первый в блоке, вставляются
    токены \texttt{``;''}, \texttt{``\}''} и вершина стека отбрасывается.
  \item Если токен находится на одинаковой колонке с первым, вставляется токен
    \texttt{``;''}.
  \end{enumerate}
\item Проверяется флаг начала блока. Если он был установлен и был считан токен
  \texttt{``\{''}, то анализатор добавляет в начало стека блоков метку о том, что
  текущий блок -- традиционный.
\item Если был прочнён любой другой токен (и флаг установлен), в начало стека
   блоков добавляется метка, что текущий блок отступо-ориентированный, вместе с
  позицией текущего токена. Перед текущим токеном вставляется токен \texttt{``\{''}.
\end{enumerate}

\begin{figure}
  \begin{tabu}{lcl}
    Expr &\rightarrow &\dots \\
    & | &BeginLet "let" "\{" Lets "\}" "in" Expr \\
    & | &"case" Expr BeginCase "of" "\{" Alts "\}" \\
    & | &\dots \\
    BeginLet &\rightarrow &$\epsilon$ \\
    BeginCase &\rightarrow &$\epsilon$
  \end{tabu}
  \caption{Изменённая грамматика для поддержки правил вложенности}
  \label{layoutgrammar}
\end{figure}

Специфическое расположение нетерминалов \texttt{Begin*} продиктовано
особенностью LALR(1)-парсера, используемого в работе -- парсер считывает один
токен вперёд, и для компенсации этого правило располагается через токен от
терминала \texttt{``\{''}.

Ещё одна специальная обработка производится для многострочных комментариев, для
которых поддерживается вложенность. Уровень вложенности считается анализатором и
режим пропускания комментария отключается при вложенности 0. Ещё один
дополнительный режим связан с распознаванием строк -- внутри строки в кавычках
допускаются экранированные произвольные символы, которые считывает и распознаёт
анализатор.

На выход лексического анализатора поступает цепочка распознанных токенов. Из-за
того что лексический и синтаксический анализаторы объединены в общем
монадическом контексте и токены получаются по одному, на практике ``цепочка''
отсутствует.

\section{Синтаксический анализ}

Синтаксический анализ языка не имеет каких-либо особенностей и проводится
обычным LALR(1) парсером. Парсер формирует полное дерево, из которого можно
восстановить исходный код вплоть до комментариев и особенностей разметки. Для
каждого узла дерева в аннотациях содержится его позиция в исходном коде; это
используется в дальнейшем для сообщений об ошибках. Схема дерева представлена на
схеме~\ref{hstree}.

\begin{figure}
  \begin{tabu}{lcl}
    HsTops &$\equiv$ &[HsTop] \\
    HsTop &\rightarrow &TopLet (HsLet) \\
    & | &TopData (HsTyDecl) \\
    HsExpr &\rightarrow &Let (HsLet, HsExpr) \\
    & | &Case (HsExpr, HsAlts) \\
    & | &App (HsExpr, HsExpr) \\
    & | &TyAnn (HsType, HsExpr) \\
    & | &Var (ValVar) \\
    & | &Lit (ValLit) \\
    HsLet &\rightarrow &LetAnn (ValVar, HsType) \\
    & | &LetBind (ValVar, HsPat, HsExpr) \\
    HsAlts &$\equiv$ &[(HsPat, HsExpr)] \\
    HsPat &\rightarrow &PatVar (ValVar) \\
    & | &PatWildCard () \\
    & | &PatCon (ValLit, HsPat) \\
    HsTyDecl &\rightarrow &HsTyDecl (TyLit, [TyVar], [HsTyCon]) \\
    HsTyCon &\rightarrow &HsTyCon (ValLit, [HsType]) \\
    HsType &\rightarrow &TypeFun \\
    & | &TypeApp (HsType, HsType) \\
    & | &TypeVar (TyVar) \\
    & | &TypeLit (TyLit)
  \end{tabu}
  \caption{Изменённая грамматика для поддержки правил вложенности}
  \label{hstree}
\end{figure}

\section{Удаление синтаксического сахара}

Полученное дерево приводится к паре более простых структур -- множеству
определённых типов и лямбда-выражению в модифицированном счислении System F с
паттерн-матчингом. Все определения типов извлекаются из оригинального набора
предложений верхнего уровня. На этом этапе проверяется, что один тип данных не
был определён два раза. Структура хранения полученных типов данных не
изменяется. Используемое лямбда-счисление:

\begin{tabu}{lcl}
  Lambda &\rightarrow &var \\
  & | &Lit \\
  & | &$\lambda$ $x$ . $e$ \\
  & | &$e_1$ $e_2$ \\
  & | &let x = $e_1$ in $e_2$ \\
  & | &case e of \{ $p_1$ \rightarrow $e_1$; \dots \}
\end{tabu}

Заметим что может показаться что конструкция \texttt{Let} здесь излишняя и может
быть выражена через комбинацию \texttt{App} и \texttt{Abs}, как то: $let x = e_1
in e_2 \equiv (\lambda x . e_2) e_1$. Это так, однако
традиционно вывод типов работает по-разному для этих конструкций -- тип
аргумента функции выводится как есть, в то время как для присвоенного имени в
\texttt{Let} выводится наиболее общий тип.  Также, как можно заметить,
структура описания типов данных напоминает упрощённое нетипизированное
лямбда-счисление (без абстракции), что будет полезно при выводе видов этих типов
(об этом ниже):

\begin{tabu}{lcl}
  Type &\rightarrow &var \\
  & | &Lit \\
  & | &(\rightarrow) \\
  & | & $e_1$ $e_2$ \\
\end{tabu}

Тип функции выделяется особо, поскольку используется при выводе типов.

Набор выражений верхнего уровня преобразуется к одному
лямбда-выражению. Переменные и литералы (названия конструкторов) переносятся как
есть. Для Let-выражений и выражений верхнего уровня производится разделение на
отдельные функции -- синтаксис паттерн-матчинга аргументов одной функции через
несколько ``определений'' здесь приводится к паттерн-матчингу через
Case. На этом же этапе производится проверка на одинаковое количество аргументов
у всех вариантов функции. Здесь же проверяется что на одном уровне (верхнем или
внутри конструкции языка \texttt{let}) нет повторно использованных имён,
поскольку в дальнейшем после преобразования в лямбда-выражение обнаружить это
будет уже невозможно. Правила упрощения таковы:

\begin{enumerate}
\item Рядом находящиеся определения функций рассматриваются как определение
  одной.
\item Создаётся новый тип n-кортежа по количеству аргументов, если такой ещё не
  был создан. Он добавляется в множество определённых типов.
\item Функция преобразуется к виду \texttt{let fun = \\arg1 arg2 -> case (arg1,
    arg2) of \{~\dots~\}}.
\item Альтернативы функции добавляются в альтернативы Case-выражения.
\item В контексте заданного Let содержится остальное выражение. Таким образом,
  остальные функции имеют доступ к только что определённой.
\end{enumerate}

Стоит отметить, что в данной работе не добавлена возможность задания рекурсивных
функций. Она была бы тривиальна (для этого необходимо применить к функции
стандартный Y-комбинатор~\cite{fixpoint}), но не реализована для повышения
читаемости результата. Возможно определение в каждом конкретном случае,
необходим ли здесь Y-комбинатор, но это потребовало бы его вставки на уровне
переименования переменных, и этого решено было избежать. Добавление комбинатора
не потребует каких-либо изменений в других модулях и достаточно просто.

Как следствие мы также не поддерживаем N-взаимную рекурсию, однако для её
поддержки требуются уже гораздо более сложные (или неочевидные) методы, например
Y*-комбинатор~\cite{oleg-ystar} с генерацией типов -- суммы N возможных
результатов функции. Получающийся конструкция тяжело читаема и
хрупка. Альтернативой является использование примитива ``unsafeCoerce'' или
``bottom'', но это выходит за рамки работы над фронтэндом.

В паттернах конструкции \texttt{Case} универсальные паттерны (wildcards)
преобразуются в обычные привязки к сгенерированному имени (гарантируется что оно
нигде не используется).

Подсказки типов добавляются как аннотации к полученному дереву вместе с позицией
в исходном коде, которая на этот момент несёт уже менее конкретный смысл
(т.к. конструкции в дереве уже не соответствуют изначальным).

Как самый внешний терм к дереву добавляется вычисление символа \texttt{main},
который будет результатом всей программы. Соответственно, символ \texttt{main}
должен быть объявлен в исходном коде, иначе произойдёт ошибка на следующем этапе
обработки дерева.

Алгоритм вычисляет пару из множества объявленных типов и лямбда-выражения, которая в
дальнейшем подвергается проходу переименования переменных.

\section{Переименование переменных}

На этом этапе для каждой логически отдельной переменной генерируется своё
уникальное название. Для этого дерево обходится с запоминанием всех уже
сгенерированных переменных в текущем контексте; все встреченные переменные
заменяются сгенерированными. Если очередная переменная не нашлась в контексте,
значит найдена свободная (необъявленная) переменная и пользователю выдаётся
ошибка. Такой же процесс осуществляется для всех типовых аннотаций и типовых
переменных. На этом этапе также обнаруживаются повторяющееся использование
переменных в \texttt{Case}-выражении, отсутствие используемых конструкторов
типов или самих типов (в аннотациях и в объявлениях абстрактных типов
данных). Также проверяется соответствие количества аргументов у конструкторов в
паттернах. Предполагается, что после этого этапа на этапе вывода и проверки
типов мы можем предполагать что единственный род ошибки который может возникнуть
-- это собственно ошибка типизации.

Выходом этого алгоритма является пара из множества объявленных типов и
лямбда-выражения, в которых в качестве имён переменных используется пара
(название, номер) в которой номер уникален для всего выражения (включая типы и
значения, что важно для упрощений следующего этапа).

\section{Вывод видов}

Для вывода типов используется классический алгоритм
Хиндли-Милнера~\cite{hindleymilner}, разделённый на две части -- вычисление
ограничений для типовых переменных и нахождение такой подстановки типовых
переменных $S$, которая удовлетворяет всем данным ограничениям. Вывод типов
проводится в два этапа, поскольку в рассматриваемом нами подмножестве языка
полностью поддерживаются абстрактные типы данных с произвольными видами. Видом
(kind) здесь и далее мы будем называть типизацию-2 (типизацию второго уровня,
т.е. типы типов данных). В данной работе не используется типизация-3 (сорты,
sorts) и далее, поскольку это значительное расширение классического Haskell
(насколько нам известно, не существует расширений или реализаций Haskell с
типами выше второго уровня, хотя подобное расширение находится в
разработке~\cite{ghc-sorts}).

Мы рассматриваем в языке простую систему видов:

\begin{tabu}{lcl}
  Kind & \rightarrow &\star \\
  & | &$k_1$ \rightarrow $k_2$
\end{tabu}

Общая идея первого этапа алгоритма заключается в обходе какого-либо дерева или
иной структуры данных и генерации ограничений для типовых переменных из этой
структуры. Во время обхода используется контекст, в котором хранятся типы
(зачастую состоящие из одной типовой переменной) для известных на текущих момент
переменных значений. Для вычисления видов (где в роли значений выступают типы)
мы создаём контекст для всех объявленных типов, присваивая им уникальные видовые
переменные. Затем мы в произвольном порядке обходим множество заданных типов,
вычисляя ограничения как для самих объявленных типов, так и для их
типов-аргументов. Поскольку на предыдущем этапе для аргументов были
сгенерированы уникальные в пределах всей программы имена, то видовые переменные
берутся с таким же названием как типовые, ``как есть'' -- это позволяет не
хранить и не использовать дополнительное отношение между типовыми и видовыми
переменными. Т.к. типы представляют собой упрощённое лямбда-счисление без
абстракции (и полиморфизма), то операции обобщения и инстанциации не
используются для генерации ограничений видов. Типы всех аргументов конструкторов
унифицируются со $\star$.

После проведения унификации типы обходятся снова -- на этот раз сгенерированная
алгоритмом унификации подстановка используется для присваивания вида каждому
литералу и переменной типа. Для конструкторов вид всегда будет $\star$. Если
унификация прошла не до конца и какая-то переменная осталась неопределённой, она
считается равной $\star$ (таким образом исключается полиморфизм видов).

На выходе алгоритма вывода видов мы получаем множество типов, в которых ко всем
литералам и переменным добавлены значения их видов.

\section{Вывод типов}

На этом этапе, используя полученное множество типов с выведенными видами, мы
проверяем верность данных пользователем типовых подсказок. Для каждой подсказки
проводится аналог алгоритма вывода видов, в котором в качестве контекста
используются уже выведенные виды всех типов. Подсказки всегда вида (и
унифицируются со) $\star$ -- соответственно, нет надобности запоминать их вид,
достаточно проверить что возможно найти подходящую подстановку.

Затем проводится обход лямбда-выражения всей программы. На уровне типов мы
допускаем полиморфизм (но не абстракцию), что выражается вводом понятия ``схемы
типа'' -- пары из типа и свободных переменных в нём:

\begin{tabu}{lcl}
  Scheme &\rightarrow &$\forall$~[$v_1$, $v_2$\dots] . t
\end{tabu}

Соответственно, контекст при первом обходе будет состоять не из типов, а из
схем, и при необходимости проводятся операции обобщения или
инстанцирования. Также используется словарь всех определённых конструкторов, для
которых конструируется соответствующий тип. В целом этот алгоритм не отличается
от его классической версии.

После унификации, как и в случае с видами, обходится всё выражение и ко всем
литералам и именам переменных добавляется их тип. Таким образом, мы получаем
конечный результат -- типизированное лямбда-выражение, которое далее возможно
преобразовать в машинный код.

\section{Вывод результатов работы}

Программа считывает исходный код из стандартного ввода, затем генерирует
отладочную информацию (промежуточные этапы работы с аннотациями) и затем выводит
результат работы в виде сериализованного Haskell-типа. Результат может быть
свободно десериализован другим модулем для генерации машинного кода. Формат
вывода промежуточных деревьев человекочитаемый.

\section{Выбранные технологии}

Для выполнения поставленной задачи был выбран язык программирования Haskell --
это связано с чрезвычайным удобством представления и работы с деревьями в
подобном языке программирования. Для работы использовался компилятор GHC 7.10 с
менеджером пакетов Nix под ОС Linux.

\section{Вывод}

Был реализован фронтэнд компилятора языка Haskell, поддерживающий подмножество
стандарта Haskell 98, включая произвольные алгебраические типы данных и
полиморфизм. В процессе был изучен механизм вывода типов Хиндли-Милнера, System
F (типизированное лямбда-счисление) и изучены техники компиляции функциональных
языков программирования и синтаксический анализ языков с пробелоориентированным
распознаванием вложенных блоков.

\printbibliography[heading=bibintoc]

\end{document}